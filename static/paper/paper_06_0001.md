### 自动寻路之A*算法  
---

#### 一. 问题情况 [SITUATION]  
自动寻路算法很多，  
包括最简单的广度优先遍历，  
以及经过预处理数据进行查找的算法。  
今天我想说的，  
是一种直接搜索的、非全局的、启发式的算法，  
A*算法。
推荐一下两篇文章：  
[《A星算法详解》](https://blog.csdn.net/hitwhylz/article/details/23089415)  
  
#### 二. 任务目标 [TASK]  
其核心公式表示为：  
f(n)=g(n)+h(n)，  
f(n) 是从初始状态经由状态n到目标状态的代价估计，  
g(n) 是在状态空间中从初始状态到状态n的实际代价，  
h(n) 是从状态n到目标状态的最佳路径的估计代价。  
  
那么A*算法的优劣实际核心就是h(n)的启发信息好坏，  
如果h(n)的启发信息好，那么很快就会得到最优结果，  
如果h(n)没有启发性，且道路可通，  
如果h(n)趋近无限大，则搜索点少，不确定为最优解；    
如果h(n)趋近0，则搜索点多，范围大，也会是最优解；  
这两种情况都会使效率很低，  
最好的办法就是使h(n)合理且有价值，  
这样才能得到效率高且最优解的A*算法。  
  
#### 三. 代码实现 [ACTION]  
接下来说一下A*算法的具体实现  
一、数据结构部分：  
两条链表  
listOpen：  
用于存储可行走路径节点  
listClose：  
用于存储无用路径节点  
链表节点：  
存储节点位置x、y信息  
f(n)、g(n)、h(n)的值  
该节点上一步的节点引用  
  
二、算法部分：  
1、把起点加入listOpen。  
然后开始重复如下过程：  
2、遍历listOpen，查找f(n)值最小的节点，把它作为当前要处理的节点。  
3、把这个节点移到listClose。  
4、对当前节点可前进的节点进行处理：  
如果它是不可抵达的或者它在listClose中，那么忽略它。  
否则的话，  
如果它不在listOpen，把它加入listOpen，并且把当前节点设置为它的父亲节点，记录该节点的f(n)、g(n)和h(n)值。  
如果它已经在listOpen中，检查这个节点路径是否更好，用g(n)值作参考。更小的g(n)值表示这是更好的路径。如果是更好，把它的父亲节点设置为当前节点，并重新计算它的f(n)、g(n)和h(n)值。  
5、让如下情况的时候循环停止：  
把终点加入到了listOpen中，说明此时路径已经找到了，  
当发现listOpen为空，说明此时没有路径，则终点不可到达。  
6、如果可到达的话保存路径。  
从终点开始，每个节点沿着父节点移动直至起点，这就是你的路径。  
  
#### 四. 结论总结 [RESULT]  
其实这个算法一开始看的时候还是非常绕的，  
不过多看几遍思路就会渐渐清晰起来。  
恩，不会算法的前端不是一个好程序猿。  