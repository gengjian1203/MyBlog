### 关于函数防抖
---

#### 一. 问题情况 [SITUATION]
我们在前端开发的过程之中，有些情况需要频繁的触发回调函数（比如：scroll、mousemove、resize等）。  
这些回调函数如果每次被调用，都去执行对应的处理函数，那么性能就会下降很多。  

#### 二. 任务目标 [TASK]  
而值得庆幸的是，有些需求的特点都是：  
在频繁的计算之下，只需要保留**最后一次结果**，其在效果上和每次计算都去执行的效果并没有太大差别。  
而这，也就是所谓的“函数防抖”。  
那么我们需要完成一段代码：  
指触发事件后在 n 秒内处理函数只能执行一次，  
等待 n 秒内，如果收到打扰，则重新计时；如果没有收到打扰，则执行函数。  

#### 三. 代码实现 [ACTION]   
``` javascript
var nNum = 0
var timer = null

// 为窗口注册鼠标移动事件
window.addEventListener("mousemove", funDebounce)

// 鼠标移动触发的回调函数
// 鼠标每次移动都会打印log，只有鼠标静止1s后，才会将数字显示
function funDebounce () {
  console.log('mousemove.')
  clearTimeout(timer)
  timer = setTimeout(() => {
    console.log(nNum++)
  }, 1000)
}
```  

#### 四. 结论总结 [RESULT]
如同上文所说，  
只要通过定时器函数**setTimeout**的特性。（即：等待一段时间再执行函数内的代码）  
在等待期间内，如果回调函数再次触发处理函数，那么重新开始等待。  
直至等待时间完成之前不被打扰，处理函数才会被执行。  
这样既达到了我们要达到的目的，也提高了性能，减少无用代码的执行。